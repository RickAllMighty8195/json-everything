using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Json.Schema.Generation.SourceGeneration.Emitters;

namespace Json.Schema.Generation.SourceGeneration;

/// <summary>
/// Emits C# code for JsonSchemaBuilder fluent calls.
/// </summary>
internal static class SchemaCodeEmitter
{
	private static readonly List<ISchemaEmitter> _emitters = new()
	{
		new BooleanSchemaEmitter(),
		new IntegerSchemaEmitter(),
		new NumberSchemaEmitter(),
		new StringSchemaEmitter(),
		new DateTimeSchemaEmitter(),
		new GuidSchemaEmitter(),
		new UriSchemaEmitter(),
		new EnumSchemaEmitter(),
		new ArraySchemaEmitter(),
		new ObjectSchemaEmitter(),
	};

	public static string EmitGeneratedClass(List<TypeInfo> types, string namespaceName)
	{
		var sb = new StringBuilder();

		// File header
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using Json.Schema;");
		sb.AppendLine();

		if (!string.IsNullOrEmpty(namespaceName))
		{
			sb.AppendLine($"namespace {namespaceName};");
			sb.AppendLine();
		}

		// Collect all custom emitter attributes
		var customAttributes = new Dictionary<string, AttributeInfo>();
		foreach (var type in types)
		{
			CollectCustomAttributes(type.TypeAttributes, customAttributes);
			foreach (var prop in type.Properties)
			{
				CollectCustomAttributes(prop.Attributes, customAttributes);
			}
		}

		// Generate extension methods for custom attributes
		if (customAttributes.Count > 0)
		{
			EmitExtensionMethods(sb, customAttributes);
			sb.AppendLine();
		}

		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Contains generated JSON schemas for types decorated with [GenerateJsonSchema].");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static class GeneratedJsonSchemas");
		sb.AppendLine("{");

		// Generate a property for each type
		foreach (var type in types)
		{
			EmitSchemaProperty(sb, type);
		}

		sb.AppendLine("}");

		return sb.ToString();
	}

	private static void EmitSchemaProperty(StringBuilder sb, TypeInfo type)
	{
		// XML doc
		if (!string.IsNullOrWhiteSpace(type.XmlDocSummary))
		{
			sb.AppendLine($"\t/// <summary>");
			sb.AppendLine($"\t/// {CodeEmitterHelpers.EscapeXmlDoc(type.XmlDocSummary)}");
			sb.AppendLine($"\t/// </summary>");
		}
		else
		{
			sb.AppendLine($"\t/// <summary>");
			sb.AppendLine($"\t/// Generated schema for <see cref=\"{type.FullyQualifiedName}\"/>.");
			sb.AppendLine($"\t/// </summary>");
		}

		sb.AppendLine($"\tpublic static readonly JsonSchema {type.SchemaPropertyName} =");
		sb.Append("\t\t");
		
		EmitSchemaBuilder(sb, type, 2);
		
		sb.AppendLine(".Build();");
		sb.AppendLine();
	}

	private static void EmitSchemaBuilder(StringBuilder sb, TypeInfo type, int indent)
	{
		var indentStr = new string('\t', indent);
		sb.Append($"new JsonSchemaBuilder()");

		// Find and use appropriate emitter
		var emitter = _emitters.FirstOrDefault(e => e.Handles(type));
		if (emitter != null)
		{
			emitter.EmitSchema(sb, type, indentStr);
		}
		else
		{
			// Fallback to object schema if no handler found
			sb.AppendLine();
			sb.Append($"{indentStr}.Type(SchemaValueType.Object)");
		}

		// Emit type-level attributes
		EmitAttributes(sb, type.TypeAttributes, indentStr);
	}

	private static void EmitAttributes(StringBuilder sb, List<AttributeInfo> attributes, string indent)
	{
		foreach (var attr in attributes)
		{
			// Handle custom emitter attributes
			if (attr.IsCustomEmitter && attr.AttributeFullName != null)
			{
				sb.AppendLine();
				sb.Append($"{indent}");
				EmitCustomAttributeCall(sb, attr);
				continue;
			}
			
			// Handle built-in validation attributes
			switch (attr.AttributeName)
			{
				case "MinimumAttribute" when attr.Parameters.TryGetValue("arg0", out var minValue):
					sb.AppendLine();
					sb.Append($"{indent}.Minimum({CodeEmitterHelpers.FormatValue(minValue)})");
					break;
				case "MaximumAttribute" when attr.Parameters.TryGetValue("arg0", out var maxValue):
					sb.AppendLine();
					sb.Append($"{indent}.Maximum({CodeEmitterHelpers.FormatValue(maxValue)})");
					break;
				case "ExclusiveMinimumAttribute" when attr.Parameters.TryGetValue("arg0", out var exMinValue):
					sb.AppendLine();
					sb.Append($"{indent}.ExclusiveMinimum({CodeEmitterHelpers.FormatValue(exMinValue)})");
					break;
				case "ExclusiveMaximumAttribute" when attr.Parameters.TryGetValue("arg0", out var exMaxValue):
					sb.AppendLine();
					sb.Append($"{indent}.ExclusiveMaximum({CodeEmitterHelpers.FormatValue(exMaxValue)})");
					break;
				case "MinLengthAttribute" when attr.Parameters.TryGetValue("arg0", out var minLen):
					sb.AppendLine();
					sb.Append($"{indent}.MinLength({CodeEmitterHelpers.FormatValue(minLen)})");
					break;
				case "MaxLengthAttribute" when attr.Parameters.TryGetValue("arg0", out var maxLen):
					sb.AppendLine();
					sb.Append($"{indent}.MaxLength({CodeEmitterHelpers.FormatValue(maxLen)})");
					break;
				case "PatternAttribute" when attr.Parameters.TryGetValue("arg0", out var pattern):
					sb.AppendLine();
					sb.Append($"{indent}.Pattern(\"{CodeEmitterHelpers.EscapeString(pattern?.ToString() ?? "")}\")");
					break;
				case "MinItemsAttribute" when attr.Parameters.TryGetValue("arg0", out var minItems):
					sb.AppendLine();
					sb.Append($"{indent}.MinItems({CodeEmitterHelpers.FormatValue(minItems)})");
					break;
				case "MaxItemsAttribute" when attr.Parameters.TryGetValue("arg0", out var maxItems):
					sb.AppendLine();
					sb.Append($"{indent}.MaxItems({CodeEmitterHelpers.FormatValue(maxItems)})");
					break;
				case "UniqueItemsAttribute":
					sb.AppendLine();
					sb.Append($"{indent}.UniqueItems(true)");
					break;
				case "MultipleOfAttribute" when attr.Parameters.TryGetValue("arg0", out var multipleOf):
					sb.AppendLine();
					sb.Append($"{indent}.MultipleOf({CodeEmitterHelpers.FormatValue(multipleOf)})");
					break;
				case "TitleAttribute" when attr.Parameters.TryGetValue("arg0", out var title):
					sb.AppendLine();
					sb.Append($"{indent}.Title(\"{CodeEmitterHelpers.EscapeString(title?.ToString() ?? "")}\")");
					break;
				case "DescriptionAttribute" when attr.Parameters.TryGetValue("arg0", out var description):
					sb.AppendLine();
					sb.Append($"{indent}.Description(\"{CodeEmitterHelpers.EscapeString(description?.ToString() ?? "")}\")");
					break;
				case "ObsoleteAttribute":
					sb.AppendLine();
					sb.Append($"{indent}.Deprecated(true)");
					break;
			}
		}
	}
	
	private static void CollectCustomAttributes(List<AttributeInfo> attributes, Dictionary<string, AttributeInfo> customAttributes)
	{
		foreach (var attr in attributes)
		{
			if (attr.IsCustomEmitter && attr.AttributeFullName != null)
			{
				// Use the full name as key to deduplicate
				if (!customAttributes.ContainsKey(attr.AttributeFullName))
				{
					customAttributes[attr.AttributeFullName] = attr;
				}
			}
		}
	}

	private static void EmitExtensionMethods(StringBuilder sb, Dictionary<string, AttributeInfo> customAttributes)
	{
		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Extension methods for custom schema attributes.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static class GeneratedSchemaExtensions");
		sb.AppendLine("{");

		foreach (var kvp in customAttributes)
		{
			var attrFullName = kvp.Key;
			var attrInfo = kvp.Value;
			
			// Extract attribute name without "Attribute" suffix
			var lastDot = attrFullName.LastIndexOf('.');
			var attrName = lastDot >= 0 ? attrFullName.Substring(lastDot + 1) : attrFullName;
			if (attrName.EndsWith("Attribute"))
				attrName = attrName.Substring(0, attrName.Length - 9);

			// Build parameter list
			var paramList = new StringBuilder("this JsonSchemaBuilder builder");
			var argList = new StringBuilder("builder");
			
			if (attrInfo.ApplyMethodParameters != null)
			{
				foreach (var param in attrInfo.ApplyMethodParameters)
				{
					paramList.Append($", {param.TypeName} {param.Name}");
					argList.Append($", {param.Name}");
				}
			}

			sb.AppendLine($"\tpublic static JsonSchemaBuilder {attrName}({paramList})");
			sb.AppendLine("\t{");
			sb.AppendLine($"\t\treturn {attrFullName}.Apply({argList});");
			sb.AppendLine("\t}");
			sb.AppendLine();
		}

		sb.AppendLine("}");
	}

	private static void EmitCustomAttributeCall(StringBuilder sb, AttributeInfo attr)
	{
		// Call the extension method with parameters
		var lastDot = attr.AttributeFullName!.LastIndexOf('.');
		var attrName = lastDot >= 0 ? attr.AttributeFullName.Substring(lastDot + 1) : attr.AttributeFullName;
		if (attrName.EndsWith("Attribute"))
			attrName = attrName.Substring(0, attrName.Length - 9);

		sb.Append($".{attrName}(");
		
		// Pass constructor arguments
		bool first = true;
		for (int i = 0; i < attr.Parameters.Count; i++)
		{
			if (attr.Parameters.TryGetValue($"arg{i}", out var value))
			{
				if (!first) sb.Append(", ");
				sb.Append(CodeEmitterHelpers.FormatValue(value));
				first = false;
			}
		}
		
		sb.Append(")");
	}
}

