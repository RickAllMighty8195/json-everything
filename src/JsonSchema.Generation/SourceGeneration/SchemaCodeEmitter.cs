using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Json.Schema.Generation.SourceGeneration.Emitters;
using Json.Schema.Generation.Serialization;
using Microsoft.CodeAnalysis;

namespace Json.Schema.Generation.SourceGeneration;

internal static class SchemaCodeEmitter
{
	public static void EmitSchemaForType(StringBuilder sb, ITypeSymbol typeSymbol, bool isNullable, string indent, SchemaEmissionContext? context = null, List<AttributeInfo>? itemAttributes = null, List<AttributeInfo>? propertyAttributes = null)
	{
		if (context != null && context.ShouldUseRef(typeSymbol))
		{
			var refUri = context.GetRefUri(typeSymbol);
			sb.AppendLine();
			
			if (isNullable)
			{
				sb.Append($"{indent}.AnyOf(");
				sb.AppendLine();
				sb.Append($"{indent}\tnew JsonSchemaBuilder().Ref(\"{refUri}\"),");
				sb.AppendLine();
				sb.Append($"{indent}\tnew JsonSchemaBuilder().Type(SchemaValueType.Null)");
				sb.AppendLine();
				sb.Append($"{indent})");
			}
			else
				sb.Append($"{indent}.Ref(\"{refUri}\")");

			return;
		}
		
		var typeKind = DetermineTypeKind(typeSymbol);
		
		if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
		{
			var typeInfo = new TypeInfo
			{
				TypeSymbol = namedTypeSymbol,
				FullyQualifiedName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
				SchemaPropertyName = "",
				PropertyNaming = NamingConvention.AsDeclared,
				PropertyOrder = PropertyOrder.AsDeclared,
				StrictConditionals = false,
				Kind = typeKind,
				IsNullable = isNullable,
				ItemAttributes = itemAttributes,
				PropertyAttributes = propertyAttributes
			};

			if (typeKind == TypeKind.Enum)
			{
				foreach (var member in namedTypeSymbol.GetMembers())
				{
					if (member is IFieldSymbol { IsConst: true, HasConstantValue: true } field)
					{
						if (CodeEmitterHelpers.ShouldIncludeEnumMember(field))
							typeInfo.EnumValues.Add(field.Name);
					}
				}
			}

			var emitter = SchemaEmitterRegistry.Emitters.FirstOrDefault(e => e.Handles(typeInfo));
			if (emitter != null)
				emitter.EmitSchema(sb, typeInfo, indent, context ?? new SchemaEmissionContext());
			else
			{
				sb.AppendLine();
				sb.Append($"{indent}.Type(SchemaValueType.Object)");
			}
		}
		else
		{
			sb.AppendLine();
			sb.Append($"{indent}.Type(SchemaValueType.Object)");
		}
	}

	private static TypeKind DetermineTypeKind(ITypeSymbol typeSymbol)
	{
		var unwrappedType = CodeEmitterHelpers.UnwrapNullable(typeSymbol);
		
		switch (unwrappedType.SpecialType)
		{
			case SpecialType.System_Boolean:
				return TypeKind.Boolean;
			case SpecialType.System_Byte:
			case SpecialType.System_SByte:
			case SpecialType.System_Int16:
			case SpecialType.System_UInt16:
			case SpecialType.System_Int32:
			case SpecialType.System_UInt32:
			case SpecialType.System_Int64:
			case SpecialType.System_UInt64:
				return TypeKind.Integer;
			case SpecialType.System_Single:
			case SpecialType.System_Double:
			case SpecialType.System_Decimal:
				return TypeKind.Number;
			case SpecialType.System_String:
				return TypeKind.String;
		}
		
		var typeString = unwrappedType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
		
		switch (typeString)
		{
			case "global::System.DateTime" or "global::System.DateTimeOffset":
				return TypeKind.DateTime;
			case "global::System.Guid":
				return TypeKind.Guid;
			case "global::System.Uri":
				return TypeKind.Uri;
		}

		if (unwrappedType.TypeKind == Microsoft.CodeAnalysis.TypeKind.Enum) return TypeKind.Enum;
		if (unwrappedType is IArrayTypeSymbol || CodeEmitterHelpers.IsCollectionType(unwrappedType)) return TypeKind.Array;

		return TypeKind.Object;
	}

	public static string EmitGeneratedClass(List<TypeInfo> types, string namespaceName)
	{
		var sb = new StringBuilder();

		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System.Runtime.CompilerServices;");
		sb.AppendLine("using System.Text.Json.Serialization;");
		sb.AppendLine("using Json.Schema;");
		sb.AppendLine("using Json.Schema.Serialization;");
		sb.AppendLine();

		if (!string.IsNullOrEmpty(namespaceName))
		{
			sb.AppendLine($"namespace {namespaceName};");
			sb.AppendLine();
		}

		var customAttributes = new Dictionary<string, AttributeInfo>();
		foreach (var type in types)
		{
			CollectCustomAttributes(type.TypeAttributes, customAttributes);
			foreach (var prop in type.Properties)
			{
				CollectCustomAttributes(prop.Attributes, customAttributes);
			}
		}

		if (customAttributes.Count > 0)
		{
			EmitExtensionMethods(sb, customAttributes);
			sb.AppendLine();
		}

		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Contains generated JSON schemas for types decorated with [GenerateJsonSchema].");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static partial class GeneratedJsonSchemas");
		sb.AppendLine("{");

		foreach (var type in types)
		{
			EmitSchemaProperty(sb, type);
		}

		sb.AppendLine("}");
		sb.AppendLine();
		
		EmitRegistrationClass(sb, types);

		return sb.ToString();
	}

	private static void EmitSchemaProperty(StringBuilder sb, TypeInfo type)
	{
		if (!string.IsNullOrWhiteSpace(type.XmlDocSummary))
		{
			sb.AppendLine($"\t/// <summary>");
			sb.AppendLine($"\t/// {CodeEmitterHelpers.EscapeXmlDoc(type.XmlDocSummary!)}");
			sb.AppendLine($"\t/// </summary>");
		}
		else
		{
			sb.AppendLine($"\t/// <summary>");
			sb.AppendLine($"\t/// Generated schema for <see cref=\"{type.FullyQualifiedName}\"/>.");
			sb.AppendLine($"\t/// </summary>");
		}

		sb.AppendLine($"\tpublic static readonly JsonSchema {type.SchemaPropertyName} =");
		sb.Append("\t\t");
		
		EmitSchemaBuilder(sb, type, 2);
		
		sb.AppendLine(".Build();");
		sb.AppendLine();
	}

	private static void EmitSchemaBuilder(StringBuilder sb, TypeInfo type, int indent)
	{
		var indentStr = new string('\t', indent);
		
		var context = AnalyzeReusedTypes(type);
		context.RootType = type.TypeSymbol;
		
		sb.Append("new JsonSchemaBuilder()");

		var emitter = SchemaEmitterRegistry.Emitters.FirstOrDefault(e => e.Handles(type));
		if (emitter != null)
		{
			emitter.EmitSchema(sb, type, indentStr, context);
		}
		else
		{
			sb.AppendLine();
			sb.Append($"{indentStr}.Type(SchemaValueType.Object)");
		}

		if (context.TypeReferences.Count > 0) 
			EmitDefs(sb, context, indentStr);

		EmitAttributes(sb, type.TypeAttributes, indentStr);
	}

	internal static void EmitAttributes(StringBuilder sb, List<AttributeInfo> attributes, string indent)
	{
		foreach (var attr in attributes)
		{
			if (attr.Parameters.TryGetValue("ConditionGroup", out var conditionGroup) && conditionGroup != null) continue;

			if (attr.IsCustomEmitter && attr.AttributeFullName != null)
			{
				sb.AppendLine();
				sb.Append($"{indent}");
				EmitCustomAttributeCall(sb, attr);
				continue;
			}

			if (!ShouldEmitBuiltInAttribute(attr)) continue;

			sb.AppendLine();
			sb.Append($"{indent}");
			EmitAttributeConstraint(sb, attr);
		}
	}

	internal static bool IsBuiltInAttributeNamespace(string? attributeFullName)
	{
		var isJsonSchemaGenerationAttr = attributeFullName?.StartsWith("global::Json.Schema.Generation.") == true;
		var isSpecialSystemAttr = attributeFullName == "global::System.ObsoleteAttribute" ||
		                          attributeFullName == "global::System.Text.Json.Serialization.JsonNumberHandlingAttribute";
		return isJsonSchemaGenerationAttr || isSpecialSystemAttr;
	}

	internal static bool ShouldEmitBuiltInAttribute(AttributeInfo attr)
	{
		return IsBuiltInAttributeNamespace(attr.AttributeFullName);
	}

	internal static void EmitAttributeConstraint(StringBuilder sb, AttributeInfo attr)
	{
		switch (attr.AttributeName)
		{
			case "MinimumAttribute" when attr.Parameters.TryGetValue("arg0", out var minValue):
				sb.Append($".Minimum({CodeEmitterHelpers.FormatValue(minValue)})");
				break;
			case "MaximumAttribute" when attr.Parameters.TryGetValue("arg0", out var maxValue):
				sb.Append($".Maximum({CodeEmitterHelpers.FormatValue(maxValue)})");
				break;
			case "ExclusiveMinimumAttribute" when attr.Parameters.TryGetValue("arg0", out var exMinValue):
				sb.Append($".ExclusiveMinimum({CodeEmitterHelpers.FormatValue(exMinValue)})");
				break;
			case "ExclusiveMaximumAttribute" when attr.Parameters.TryGetValue("arg0", out var exMaxValue):
				sb.Append($".ExclusiveMaximum({CodeEmitterHelpers.FormatValue(exMaxValue)})");
				break;
			case "MinLengthAttribute" when attr.Parameters.TryGetValue("arg0", out var minLen):
				sb.Append($".MinLength({CodeEmitterHelpers.FormatValue(minLen)})");
				break;
			case "MaxLengthAttribute" when attr.Parameters.TryGetValue("arg0", out var maxLen):
				sb.Append($".MaxLength({CodeEmitterHelpers.FormatValue(maxLen)})");
				break;
			case "PatternAttribute" when attr.Parameters.TryGetValue("arg0", out var pattern):
				sb.Append($".Pattern(\"{CodeEmitterHelpers.EscapeString(pattern?.ToString() ?? "")}\")");
				break;
			case "MinItemsAttribute" when attr.Parameters.TryGetValue("arg0", out var minItems):
				sb.Append($".MinItems({CodeEmitterHelpers.FormatValue(minItems)})");
				break;
			case "MaxItemsAttribute" when attr.Parameters.TryGetValue("arg0", out var maxItems):
				sb.Append($".MaxItems({CodeEmitterHelpers.FormatValue(maxItems)})");
				break;
			case "UniqueItemsAttribute":
				sb.Append($".UniqueItems(true)");
				break;
			case "MultipleOfAttribute" when attr.Parameters.TryGetValue("arg0", out var multipleOf):
				sb.Append($".MultipleOf({CodeEmitterHelpers.FormatValue(multipleOf)})");
				break;
			case "TitleAttribute" when attr.Parameters.TryGetValue("arg0", out var title):
				sb.Append($".Title(\"{CodeEmitterHelpers.EscapeString(title?.ToString() ?? "")}\")");
				break;
			case "DescriptionAttribute" when attr.Parameters.TryGetValue("arg0", out var description):
				sb.Append($".Description(\"{CodeEmitterHelpers.EscapeString(description?.ToString() ?? "")}\")");
				break;
			case "ObsoleteAttribute":
				sb.Append($".Deprecated(true)");
				break;
			case "ReadOnlyAttribute":
				sb.Append($".ReadOnly(true)");
				break;
			case "WriteOnlyAttribute":
				sb.Append($".WriteOnly(true)");
				break;
		}
	}

	private static void CollectCustomAttributes(List<AttributeInfo> attributes, Dictionary<string, AttributeInfo> customAttributes)
	{
		foreach (var attr in attributes)
		{
			if (attr is { IsCustomEmitter: true, AttributeFullName: not null }) 
				customAttributes.TryAdd(attr.AttributeFullName, attr);
		}
	}

	private static void EmitExtensionMethods(StringBuilder sb, Dictionary<string, AttributeInfo> customAttributes)
	{
		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Extension methods for custom schema attributes.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("public static class GeneratedSchemaExtensions");
		sb.AppendLine("{");

		foreach (var kvp in customAttributes)
		{
			var attrFullName = kvp.Key;
			var attrInfo = kvp.Value;
			
			var lastDot = attrFullName.LastIndexOf('.');
			var attrName = lastDot >= 0 ? attrFullName.Substring(lastDot + 1) : attrFullName;
			if (attrName.EndsWith("Attribute"))
				attrName = attrName.Substring(0, attrName.Length - 9);

			var paramList = new StringBuilder("this JsonSchemaBuilder builder");
			var argList = new StringBuilder("builder");
			
			if (attrInfo.ApplyMethodParameters != null)
			{
				foreach (var param in attrInfo.ApplyMethodParameters)
				{
					paramList.Append($", {param.TypeName} {param.Name}");
					argList.Append($", {param.Name}");
				}
			}

			sb.AppendLine($"\tpublic static JsonSchemaBuilder {attrName}({paramList})");
			sb.AppendLine("\t{");
			sb.AppendLine($"\t\treturn {attrFullName}.Apply({argList});");
			sb.AppendLine("\t}");
			sb.AppendLine();
		}

		sb.AppendLine("}");
	}

	private static void EmitCustomAttributeCall(StringBuilder sb, AttributeInfo attr)
	{
		var lastDot = attr.AttributeFullName!.LastIndexOf('.');
		var attrName = lastDot >= 0 ? attr.AttributeFullName.Substring(lastDot + 1) : attr.AttributeFullName;
		if (attrName.EndsWith("Attribute"))
			attrName = attrName.Substring(0, attrName.Length - 9);

		sb.Append($".{attrName}(");
		
		var first = true;
		
		if (attr.ApplyMethodParameters != null && attr.ApplyMethodParameters.Count > 0)
		{
			foreach (var param in attr.ApplyMethodParameters)
			{
				if (!first)
					sb.Append(", ");
				
				object? value = null;
				var found = false;
				
				for (int i = 0; i < attr.Parameters.Count; i++)
				{
					if (attr.Parameters.TryGetValue($"arg{i}", out value))
					{
						if (i == attr.ApplyMethodParameters.IndexOf(param))
						{
							found = true;
							break;
						}
					}
				}
				
				if (!found)
				{
					foreach (var kvp in attr.Parameters)
					{
						if (!kvp.Key.StartsWith("arg") && 
						    string.Equals(kvp.Key, param.Name, StringComparison.OrdinalIgnoreCase))
						{
							value = kvp.Value;
							found = true;
							break;
						}
					}
				}

				sb.Append(found
					? CodeEmitterHelpers.FormatValue(value)
					: "0");

				first = false;
			}
		}
		else
		{
			for (int i = 0; i < attr.Parameters.Count; i++)
			{
				if (attr.Parameters.TryGetValue($"arg{i}", out var value))
				{
					if (!first)
						sb.Append(", ");

					sb.Append(CodeEmitterHelpers.FormatValue(value));
					first = false;
				}
			}
		}
		
		sb.Append(")");
	}

	private static SchemaEmissionContext AnalyzeReusedTypes(TypeInfo type)
	{
		var context = new SchemaEmissionContext();
		
		var typeCounts = new Dictionary<string, (ITypeSymbol Symbol, int Count)>();
		
		foreach (var prop in type.Properties)
		{
			CollectPropertyTypes(prop.Type, typeCounts);
		}
		
		foreach (var kvp in typeCounts)
		{
			if (kvp.Value.Count > 1)
			{
				var defName = SchemaEmissionContext.GetDefinitionName(kvp.Value.Symbol);
				context.TypeReferences[kvp.Key] = (defName, kvp.Value.Symbol);
			}
		}
		
		return context;
	}

	private static void CollectPropertyTypes(ITypeSymbol typeSymbol, Dictionary<string, (ITypeSymbol Symbol, int Count)> typeCounts)
	{
		var unwrapped = CodeEmitterHelpers.UnwrapNullable(typeSymbol);
		
		var typeKind = DetermineTypeKind(unwrapped);
		if (typeKind is TypeKind.Boolean or TypeKind.Integer or TypeKind.Number or 
		    TypeKind.String or TypeKind.DateTime or TypeKind.Guid or TypeKind.Uri or TypeKind.Enum)
			return;
		
		if (typeKind == TypeKind.Array)
		{
			var elementType = CodeEmitterHelpers.GetElementType(unwrapped);
			if (elementType != null) 
				CollectPropertyTypes(elementType, typeCounts);

			return;
		}
		
		if (typeKind == TypeKind.Object)
		{
			var typeKey = SchemaEmissionContext.GetTypeKey(unwrapped);
			if (typeCounts.TryGetValue(typeKey, out var existing))
				typeCounts[typeKey] = (existing.Symbol, existing.Count + 1);
			else
				typeCounts[typeKey] = (unwrapped, 1);
		}
	}

	private static void EmitDefs(StringBuilder sb, SchemaEmissionContext context, string indent)
	{
		sb.AppendLine();
		sb.Append($"{indent}.Defs(");
		sb.AppendLine();
		
		var first = true;
		foreach (var kvp in context.TypeReferences)
		{
			if (!first)
			{
				sb.Append(",");
				sb.AppendLine();
			}
			first = false;
			
			var (defName, typeSymbol) = kvp.Value;
			sb.Append($"{indent}\t(\"{defName}\", new JsonSchemaBuilder()");
			
			if (typeSymbol is INamedTypeSymbol namedType)
			{
				var typeInfo = BuildTypeInfoForRef(namedType);
				var emitter = SchemaEmitterRegistry.Emitters.FirstOrDefault(e => e.Handles(typeInfo));
				if (emitter != null)
					emitter.EmitSchema(sb, typeInfo, indent + "\t\t", new SchemaEmissionContext());
				else
				{
					sb.AppendLine();
					sb.Append($"{indent}\t\t.Type(SchemaValueType.Object)");
				}
			}
			else
			{
				sb.AppendLine();
				sb.Append($"{indent}\t\t.Type(SchemaValueType.Object)");
			}
			
			sb.Append(")");
		}
		
		sb.AppendLine();
		sb.Append($"{indent})");
	}

	private static TypeInfo BuildTypeInfoForRef(INamedTypeSymbol typeSymbol)
	{
		var typeKind = DetermineTypeKind(typeSymbol);
		var typeInfo = new TypeInfo
		{
			TypeSymbol = typeSymbol,
			FullyQualifiedName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
			SchemaPropertyName = "",
			PropertyNaming = NamingConvention.AsDeclared,
			PropertyOrder = PropertyOrder.AsDeclared,
			StrictConditionals = false,
			Kind = typeKind,
			IsNullable = false
		};

		if (typeKind == TypeKind.Object)
		{
			foreach (var member in typeSymbol.GetMembers())
			{
				ITypeSymbol? memberType;
				bool isReadOnly;
				var isWriteOnly = false;

				if (member is IPropertySymbol property)
				{
					if (property.DeclaredAccessibility != Accessibility.Public) continue;

					memberType = property.Type;
					isReadOnly = property.SetMethod == null;
					isWriteOnly = property.GetMethod == null;

					if (isWriteOnly) continue;
				}
				else if (member is IFieldSymbol field)
				{
					if (field.DeclaredAccessibility != Accessibility.Public) continue;

					memberType = field.Type;
					isReadOnly = field.IsReadOnly;
				}
				else continue;

				var schemaName = member.Name;
				var isRequired = false;
				if (member is IPropertySymbol prop)
					isRequired = prop.IsRequired;

				var isNullable = memberType.NullableAnnotation == NullableAnnotation.Annotated;

				var propertyInfo = new PropertyInfo
				{
					Name = member.Name,
					SchemaName = schemaName,
					Type = memberType,
					IsRequired = isRequired,
					IsNullable = isNullable,
					IsReadOnly = isReadOnly,
					IsWriteOnly = isWriteOnly
				};

				typeInfo.Properties.Add(propertyInfo);
			}
		}
		else if (typeKind == TypeKind.Enum)
		{
			foreach (var member in typeSymbol.GetMembers())
			{
				if (member is IFieldSymbol { IsConst: true, HasConstantValue: true } field)
				{
					if (CodeEmitterHelpers.ShouldIncludeEnumMember(field))
						typeInfo.EnumValues.Add(field.Name);
				}
			}
		}

		return typeInfo;
	}

	private static void EmitRegistrationClass(StringBuilder sb, List<TypeInfo> types)
	{
		sb.AppendLine("/// <summary>");
		sb.AppendLine("/// Registers generated schemas with the ValidatingJsonConverter for AOT scenarios.");
		sb.AppendLine("/// </summary>");
		sb.AppendLine("internal static class GeneratedSchemaRegistration");
		sb.AppendLine("{");
		sb.AppendLine("\t[ModuleInitializer]");
		sb.AppendLine("\tinternal static void RegisterSchemas()");
		sb.AppendLine("\t{");

		foreach (var type in types)
		{
			sb.AppendLine($"\t\tValidatingJsonConverter.RegisterConverter(");
			sb.AppendLine($"\t\t\ttypeof({type.FullyQualifiedName}),");
			sb.AppendLine($"\t\t\tnew ValidatingJsonConverter<{type.FullyQualifiedName}>(");
			sb.AppendLine($"\t\t\t\tGeneratedJsonSchemas.{type.SchemaPropertyName},");
			sb.AppendLine($"\t\t\t\tValidatingJsonConverter.DefaultOptionsFactory));");
		}

		sb.AppendLine("\t}");
		sb.AppendLine("}");
	}
}
